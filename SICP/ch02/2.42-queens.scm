(define (queens board-size)
   (define (flatmap proc seq)
     (accumulate append () (map proc seq)))
   (define (accumulate op initial items)
     (cond ((null? items) initial)
	   (else (accumulate op (op (car items) initial) (cdr items)))))
   (define (enumerate-interval low high)
     (cond ((> low high) ())
	   (else (cons low (enumerate-interval (+ low 1) high)))))
   (define empty-board ())
   (define (adjoin-position new-row k rest-of-queens)
     (cons new-row rest-of-queens))
   (define (safe? k position)
     (iter-check (car position)
		 (cdr position)
		 1))
   (define (iter-check row-of-new-queen rest-of-queens i)
     (if (null? rest-of-queens)
         #t
	 (let ((row-of-current-queen (car rest-of-queens)))
	   (if (or (= row-of-new-queen row-of-current-queen)
		   (= row-of-new-queen (+ row-of-current-queen i))
		   (= row-of-new-queen (- row-of-current-queen i)))
	       #f
	       (iter-check row-of-new-queen (cdr rest-of-queens) (+ i 1))))))
   (define (queen-cols k)
     (if (= k 0)
         (list empty-board)
	 (filter (lambda (positions) (safe? k positions))
		 (flatmap (lambda (rest-of-queens)
			    (map (lambda (new-row)
				   (adjoin-position new-row k rest-of-queens))
				 (enumerate-interval 1 board-size)))
			  (queen-cols (- k 1))))))
   (let ((items (queen-cols board-size)))
     (display "There are ")
     (display (length items))
     (display " ways in ")
     (display board-size)
     (display " queens.")
     (newline)
     (for-each (lambda (pos) (begin (display pos) (newline))) items)))
