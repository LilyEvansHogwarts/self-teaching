(load "2.78-tag.scm")

(define tower '(scheme-number rational complex))

(define (element-of? x lst)
  (cond ((null? lst) #f)	
	((eq? x (car lst)) #t)
	(else (element-of? x (cdr lst)))))

(define (keep-drop x)
  (cond ((not (pair? x)) x)
        ((not (element-of? (type-tag x) tower)) x)
        ((eq? (type-tag x) (car tower)) x)
        ((eq? (type-tag (drop x)) (type-tag x)) x)
        (else (keep-drop (drop x)))))

(define (raise-into args1 args2 lst)
  (let ((type1 (type-tag args1))
        (type2 (type-tag args2))
	(current (car lst))
	(next-lst (cdr lst)))
    (cond ((null? next-lst) current)
	  ((eq? type1 current) type2)
	  ((eq? type2 current) type1)
	  (else (raise-into args1 args2 next-lst)))))

(define (change-type arg)
  (let ((args1 (car arg))
	(args2 (cadr arg)))
    (let ((type1 (type-tag args1))
	  (type2 (type-tag args2))
	  (s (raise-into args1 args2 tower)))
      (cond ((and (eq? type1 type2) (eq? s type1) (eq? s type2)) (list args1 args2)) 
	    ((eq? s type1) (change-type (list args1 (raise args2))))
	    ((eq? s type2) (change-type (list (raise args1) args2)))))))
