#lang swindle

(define (require p)
   (if (not p) (amb)))
  
(define (distinct? items)
  (define (iter y xs)
  (cond ((null? xs) (distinct? (cdr items)))
             ((eq? (car xs) y) false)
            (else (iter y (cdr xs)))))
    (if (null? items)
        true
       (let ((y (car items)))
          (iter y (cdr items)))))

(define (multiple-dwelling-1)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))))
 
(define (multiple-dwelling-2)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))))
 
(define (multiple-dwelling-3)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require (> miller cooper))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (require (distinct? (list baker cooper fletcher miller smith)))))

(define tests 100)
 
(collect-garbage)
(time 
 (let next ((x tests))
   (cond ((zero? x) 'done)
         (else (multiple-dwelling-1)
               (next (- x 1))))))
 
(collect-garbage)
(time 
 (let next ((x tests))
   (cond ((zero? x) 'done)
         (else (multiple-dwelling-2)
               (next (- x 1))))))

(collect-garbage)
(time 
 (let next ((x tests))
   (cond ((zero? x) 'done)
         (else (multiple-dwelling-3)
               (next (- x 1))))))
