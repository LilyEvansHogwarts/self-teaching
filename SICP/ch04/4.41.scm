(define (choose? items)
 (let ((baker (car items))
	   (cooper (cadr items))
	   (fletcher (caddr items))
	   (miler (cadddr items))
	   (smith (car (cddddr items))))
  (and (not (= baker 5)) 
	   (not (= cooper 1)) 
	   (not (= fletcher 1)) 
	   (not (= fletcher 5)) 
	   (> miler cooper)
	   (not (= 1 (abs (- smith fletcher))))
	   (not (= 1 (abs (- fletcher cooper))))
	   (distinct? items))))

(define (distinct? items)
 (cond ((null? items) true)
	   ((null? (cdr items)) true)
	   ((member (car items) (cdr items)) false)
	   (else (distinct? (cdr items)))))

(define (flatmap proc li)
 (if (null? li)
  '()
  (append (proc (car li)) (flatmap proc (cdr li)))))

(define (permutation items)
 (if (null? items)
  '(())
  (flatmap (lambda (x)
			(map (lambda (y) (cons x y)) (permutation (cdr items))))
   (car items))))

(define (multiple-dwelling)
 (let ((baker (list 1 2 3 4 5))
	   (cooper (list 1 2 3 4 5))
	   (fletcher (list 1 2 3 4 5))
	   (miler (list 1 2 3 4 5))
	   (smith (list 1 2 3 4 5)))
  (let ((items (filter choose? (permutation (list baker cooper fletcher miler smith)))))
   (map (lambda (x) (apply (lambda (baker cooper fletcher miler smith)
							(list (list 'baker baker)
								  (list 'cooper cooper)
								  (list 'fletcher fletcher)
								  (list 'miler miler)
								  (list 'smith smith)))
					 x))
	items))))
